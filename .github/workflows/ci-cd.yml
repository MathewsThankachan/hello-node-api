name: CI/CD

on:
  push:
    branches: ["dev", "qa"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment (dev, qa, prod)"
        required: true
        default: "dev"

env:
  IMAGE_REPO: ${{ secrets.IMAGE_REPOSITORY }}

jobs:
  build-and-push:
    name: Build and push image
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.set-tag.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Set image tag
        id: set-tag
        run: |
          echo "image_tag=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

      - name: Log in to registry
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: |
            ${{ env.IMAGE_REPO }}:${{ steps.set-tag.outputs.image_tag }}
            ${{ env.IMAGE_REPO }}:latest

  deploy:
    name: Deploy to environment
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - uses: actions/checkout@v4

      - name: Set variables
        id: vars
        run: |
          echo "TAG=${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_OUTPUT
          # Determine environment: workflow_dispatch input wins, else branch-based mapping
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            echo "ENVIRONMENT=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            if [ "${GITHUB_REF}" = "refs/heads/qa" ]; then echo "ENVIRONMENT=qa" >> $GITHUB_OUTPUT; fi
            if [ "${GITHUB_REF}" = "refs/heads/dev" ]; then echo "ENVIRONMENT=dev" >> $GITHUB_OUTPUT; fi
          fi

      - name: Determine target kubeconfig secret
        id: kube-select
        run: |
          if [ "${{ steps.vars.outputs.ENVIRONMENT }}" = "dev" ]; then echo "KUBE_SECRET=KUBE_CONFIG_DEV" >> $GITHUB_OUTPUT; fi
          if [ "${{ steps.vars.outputs.ENVIRONMENT }}" = "qa" ]; then echo "KUBE_SECRET=KUBE_CONFIG_QA" >> $GITHUB_OUTPUT; fi
          if [ "${{ steps.vars.outputs.ENVIRONMENT }}" = "prod" ]; then echo "KUBE_SECRET=KUBE_CONFIG_PROD" >> $GITHUB_OUTPUT; fi

      - name: Configure kubeconfig
        run: |
          # The workflow expects environment-specific kubeconfigs set as secrets:
          # KUBE_CONFIG_DEV, KUBE_CONFIG_QA and KUBE_CONFIG_PROD. They should be
          # base64-encoded kubeconfig files. This step will pick the correct
          # secret based on the environment, decode it, and write it to $HOME/.kube/config.
          set -e
          KUBE_B64=""
          if [ "${{ steps.kube-select.outputs.KUBE_SECRET }}" = "KUBE_CONFIG_QA" ]; then KUBE_B64="${{ secrets.KUBE_CONFIG_QA }}"; fi
          if [ "${{ steps.kube-select.outputs.KUBE_SECRET }}" = "KUBE_CONFIG_PROD" ]; then KUBE_B64="${{ secrets.KUBE_CONFIG_PROD }}"; fi
          if [ "${{ steps.kube-select.outputs.KUBE_SECRET }}" = "KUBE_CONFIG_DEV" ]; then KUBE_B64="${{ secrets.KUBE_CONFIG_DEV }}"; fi
          if [ -z "$KUBE_B64" ]; then echo "Missing kubeconfig secret for target environment"; exit 1; fi
          echo "$KUBE_B64" | base64 --decode > kubeconfig
          mkdir -p $HOME/.kube
          mv kubeconfig $HOME/.kube/config

      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Install helm
        uses: azure/setup-helm@v1

      - name: Helm upgrade/install
        run: |
          VALUES_FILE=chart/hello-node-api/values-${{ steps.vars.outputs.ENVIRONMENT }}.yaml
          if [ ! -f "$VALUES_FILE" ]; then echo "Values file $VALUES_FILE not found, aborting"; exit 1; fi
          # Read the weatherApi.keySecretName from the values file (if present)
          WEATHER_SECRET=$(sed -n 's/^[[:space:]]*keySecretName:[[:space:]]*\(["'"']\{0,1\}\)\(.*\)\1$/\2/p' "$VALUES_FILE" | tr -d '\r')
          # Fallback for unquoted values (simple parser)
          if [ -z "$WEATHER_SECRET" ]; then
            WEATHER_SECRET=$(grep -E '^[[:space:]]*keySecretName:' "$VALUES_FILE" | sed 's/^[[:space:]]*keySecretName:[[:space:]]*//; s/["'"']//g' | tr -d '\r')
          fi
          if [ -n "$WEATHER_SECRET" ]; then
            echo "Using weather secret from values file: $WEATHER_SECRET"
            WEATHER_ARG="--set weatherApi.keySecretName=$WEATHER_SECRET"
          else
            echo "No weather secret configured in $VALUES_FILE; continuing without --set weatherApi.keySecretName"
            WEATHER_ARG=""
          fi
          helm upgrade --install my-release chart/hello-node-api \
            --namespace ${{ steps.vars.outputs.ENVIRONMENT }} --create-namespace \
            -f "$VALUES_FILE" \
            --set image.repository=${{ env.IMAGE_REPO }} \
            --set image.tag=${{ needs.build-and-push.outputs.image-tag }} \
            $WEATHER_ARG \
            --wait
